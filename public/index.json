[{"content":"Introduction Oncoplots are types of plots that help to visualise genetic mutations across different genes and patients. The plot allows to simultaneously view the most mutated genes as well as co-occuring mutations in the individuals. Commonly the genes carrying mutations/variants are the rows and the individuals carrying mutations are the columns.\n[figure of example oncoplot]\nOncoplots are often presented with additional info such as clinical parameters that can be added under, top, or to the sides of the oncoplot.\nThere are several tools for creating oncoplots and currently the most popular one is Bioconductor\u0026rsquo;s maftools oncoplot.\nTutorial Data requirements For this tutorial, you need genetic mutation data in MAF format. You can refer to this previous post on how to convert your annotated data into MAF format with a simple piece of code, or follow vcf2maf tutorial if you have VCF file.\nIf you want to add clinical information as metadata to the oncoplot, you need the clinical data in tabular format:\nTool requirements References maftools link vcf2maf link ","permalink":"http://localhost:1313/posts/oncoplot/","summary":"Introduction Oncoplots are types of plots that help to visualise genetic mutations across different genes and patients. The plot allows to simultaneously view the most mutated genes as well as co-occuring mutations in the individuals. Commonly the genes carrying mutations/variants are the rows and the individuals carrying mutations are the columns.\n[figure of example oncoplot]\nOncoplots are often presented with additional info such as clinical parameters that can be added under, top, or to the sides of the oncoplot.","title":"Oncoplot"},{"content":"Check all articles in this list.\nMAF files Mutation Annotation Format (MAF) is a data format used to store mutation data. Some visualization tools such as Bioconductor\u0026rsquo;s oncoplot, require the data to be in MAF format.\nMAF files have mandatory and optional fields. Mandatory fields:\nHugo_Symbol: Gene name (it\u0026rsquo;s Hugo nomenclature name) Chromosome Start_Position End_Position Reference_allele Tumor_Seq_Allele2: alternative allele Variant_Classification: variant consequence eg. missense, stop, splice Variant_Type: single nucleotide variant, insertion, deletion Tumor_Sample_Barcode:\tTumor/Patient/Sample name or number Optional fields:\nnon MAF specific fields containing VAF and amino acid change information Generating MAF files When generating MAF files your starting point is usually a VCF file or a tabular file with or without annotations. Tool vcf2maf will annotate, prioritize transcripts, and generates a MAF suitable for further use. The tool requires VEP to be installed in order for it to be able to do the annotations for mutations.\nBecause I already had a VEP-annotated tabular file, I used python to generate MAF file and R to change the values in Variant_Type and Variant_Classification columns to be maftools oncoplot compatible. More about bioconductor\u0026rsquo;s maftools can be found here.\nVEP annotated tabular file to MAF file Taking the required fields from the VEP-annotated tabular file and renaming the column names into oncoplot suitable ones.\n1import pandas as pd 2 3def make_maf(data): 4\tdata[\u0026#39;End_Position\u0026#39;] = data[\u0026#39;pos\u0026#39;] + 1 5\tmaf = data[[\u0026#39;SYMBOL\u0026#39;,\u0026#39;chrom\u0026#39;,\u0026#39;pos\u0026#39;,\u0026#39;End_Position\u0026#39;,\u0026#39;ref\u0026#39;,\u0026#39;alt\u0026#39;,\u0026#39;Consequence\u0026#39;,\u0026#39;VARIANT_CLASS\u0026#39;, \u0026#39;patient\u0026#39;]] 6\tmaf.columns = [\u0026#39;Hugo_Symbol\u0026#39;, \u0026#39;Chromosome\u0026#39;,\u0026#39;Start_Position\u0026#39;,\u0026#39;End_Position\u0026#39;, \u0026#39;Reference_Allele\u0026#39;, \u0026#39;Tumor_Seq_Allele2\u0026#39;,\u0026#39;Variant_Classification\u0026#39;,\u0026#39;Variant_Type\u0026#39;,\u0026#39;Tumor_Sample_Barcode\u0026#39;] 7\treturn maf 8 9maf = make_maf(data) Modify variant annotations In addition to VEP, there\u0026rsquo;s another popular variant annotation tool ANNOVAR. They use a bit different nomenclature on the variant consequence and variant type fields. Maftools oncoplot uses the ANNOVAR type of annotations and hence in R, I change the Variant_Type and Variant_Classification values from VEP nomenclature to ANNOVAR nomenclature.\n1library(dplyr) 2 3data \u0026lt;- read.table(\u0026#39;variants.maf\u0026#39;, sep=\u0026#39;\\t\u0026#39;, header=TRUE) 4 5change_values \u0026lt;- function(df) { 6\tdf \u0026lt;- df %\u0026gt;% 7\tmutate(Variant_Classification = case_when((Variant_Classification == \u0026#39;missense_variant\u0026#39;) ~ \u0026#39;Missense_Mutation\u0026#39;, 8\t(Variant_Classification == \u0026#39;stop_gained\u0026#39;) ~ \u0026#39;Nonsense_Mutation\u0026#39;, 9\t(Variant_Classification == \u0026#39;splice_acceptor_variant\u0026#39;) ~ \u0026#39;Splice_Site\u0026#39;, 10\t(Variant_Classification == \u0026#39;splice_donor_variant\u0026#39;) ~ \u0026#39;Splice_Site\u0026#39;, 11\t(Variant_Classification == \u0026#39;missense_variant\u0026amp;splice_region_variant\u0026#39;) ~ \u0026#39;Missense_Mutation\u0026#39;, 12\t(Variant_Classification == \u0026#39;frameshift_variant\u0026#39; \u0026amp; Variant_Type ==\u0026#39;deletion\u0026#39;) ~ \u0026#39;Frame_Shift_Del\u0026#39;, 13\t(Variant_Classification == \u0026#39;start_lost\u0026#39;) ~ \u0026#39;Nonsense_Mutation\u0026#39;, 14\t(Variant_Classification == \u0026#39;frameshift_variant \u0026amp; Variant_Type == \u0026#39;insertion\u0026#39;) ~ \u0026#39;Frame_Shift_Ins\u0026#39;)) %\u0026gt;% 15\tmutate(Variant_Type = case_when((Variant_Type == \u0026#39;SNV\u0026#39;) ~ \u0026#39;SNP\u0026#39;, 16\t(Variant_Type == \u0026#39;insertion\u0026#39;) ~ \u0026#39;INS\u0026#39;, 17\t(Variant_Type == \u0026#39;deletion\u0026#39;) ~ \u0026#39;DEL\u0026#39;)) 18 19\treturn(df) 20} 21 22data \u0026lt;- change_values(data) Be careful with the variant nomenclature Each tool, VEP, ANNOVAR, and other annotation tools use different systems for variant nomenclature and they may vary. ANNOVAR annotations are more general compared to VEP. For example, in ANNOVAR, splice-site variants are annotated as \u0026lsquo;Splice_Site\u0026rsquo;, whereas in VEP they are annotated as \u0026lsquo;splice_acceptor_variant\u0026rsquo; or \u0026lsquo;splice_donor_variant\u0026rsquo; depending on their location. In addition, variants in multiple transcripts are dealt with differently. Some tools list each different annotation the variant gets in the different transcripts whereas for example, ANNOVAR outputs only the most deleterious variant based on their priorisation system.\nReferences VEP: https://asia.ensembl.org/info/docs/tools/vep/index.html ANNOVAR: https://annovar.openbioinformatics.org/en/latest/\n","permalink":"http://localhost:1313/posts/make-maf-for-oncoplot/","summary":"Check all articles in this list.\nMAF files Mutation Annotation Format (MAF) is a data format used to store mutation data. Some visualization tools such as Bioconductor\u0026rsquo;s oncoplot, require the data to be in MAF format.\nMAF files have mandatory and optional fields. Mandatory fields:\nHugo_Symbol: Gene name (it\u0026rsquo;s Hugo nomenclature name) Chromosome Start_Position End_Position Reference_allele Tumor_Seq_Allele2: alternative allele Variant_Classification: variant consequence eg. missense, stop, splice Variant_Type: single nucleotide variant, insertion, deletion Tumor_Sample_Barcode:\tTumor/Patient/Sample name or number Optional fields:","title":"Make Maf for Oncoplot"},{"content":"","permalink":"http://localhost:1313/posts/lollipop-plots/","summary":"","title":"Lollipop Plots"},{"content":"","permalink":"http://localhost:1313/posts/circos-plots/","summary":"","title":"Circos Plots"},{"content":"What is a reference genome? A human reference genome, reference assembly, is a sequence of nucleotides representing genes and non-coding regions of the genome. It is made up from a combination multiple individual\u0026rsquo;s DNA and hence not representing a genome of any single human but an average of all humans in the world. However, it is difficult to get proper representation of all humans due to the bias in the selection of participants for the genome sequencing and the great variantion in some parts of the genome between populations. The first version was released in 2000 and there have been multiple improvements and versions after that.\nWhat is it used for? Reference genomes are used in genetic research as a reference map to help assemble sequencing data. They are also used in sample comparison to identify differences in the genome between individuals.\nWhat are the different versions? Institutional differences There are number of reference genome assemblies available from different sources which are then named based on the institution.\nReference Institute Contig names Resource Notes GRCh37, GRCh38 The Genome Reference Consortium (GRC) chr prefix ftp://ftp.ncbi.nlm.nih.gov/genomes/refseq/vertebrate_mammalian/Homo_sapiens/all_assembly_versions/GCF_000001405.25_GRCh37.p13/GCF_000001405.25_GRCh37.p13_genomic.fna.gz Constructed from sequenced bacterial artificial chromosomes (BACs) hg19, hg38 The University of California at Santa Cruz (UCSC) chr prefix http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/hg19.fa.gz Based on GRCh reference but contains some alterations b37 Broad institute no \u0026lsquo;chr\u0026rsquo; prefix https://console.cloud.google.com/storage/browser/_details/broad-references/hg19/v0/Homo_sapiens_assembly19.fasta Based on GRCh. Alterations: bases with low confidence masked out. human_g1k_v37 The 1000 Genome project No \u0026lsquo;chr\u0026rsquo; prefix http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/reference/human_g1k_v37.fasta.gz Equivalent to b37, but without human herpesvirus 4 type 1 decoy sequence Mostly the references contain the same data, although they use different naming for contigs (hg19 and GRCh use ‘chr’ prefix whereas other two don’t).\nHowever, there are some sequence differences between the references. There are differences on chromosomes 3 and Y, and mitochondrial contig as can be seen on the reference comparison table at broad institutes article linked below.\nRelease builds 37 vs 38 Each major version of human reference genome assemblies are numbered differently and the latest ones are GRCh37 (release 2009) and GRCh38 (release 2013) (hg19 and hg38 in the UCSC). Each version comes with updated annotations to the earlier.\nGRCh38 assembly has repaired incorrect reads and misassembled areas in GRCh37. In addition, it has been updated to include model centromere sequences and alternate loci. GRCh38 has greater amoun of ALT contigs, which are pieces of genome that represent alternative haplotypes.\nReferences: https://www.science.org/doi/10.1126/science.abj6987\nhttps://gatk.broadinstitute.org/hc/en-us/articles/360035890711-GRCh37-hg19-b37-humanG1Kv37-Human-Reference-Discrepancies?id=23390\nhttps://www.ncbi.nlm.nih.gov/grc\n","permalink":"http://localhost:1313/posts/human-reference-genomes/","summary":"What is a reference genome? A human reference genome, reference assembly, is a sequence of nucleotides representing genes and non-coding regions of the genome. It is made up from a combination multiple individual\u0026rsquo;s DNA and hence not representing a genome of any single human but an average of all humans in the world. However, it is difficult to get proper representation of all humans due to the bias in the selection of participants for the genome sequencing and the great variantion in some parts of the genome between populations.","title":"Human Reference Genomes: GRCh37, GRCh38, hg19, hg38, v37, b37?"},{"content":"Germline variant effect interpretation is challenging Assessing the clinical significance of germline variants is an important task in genetics. Identification of pathogenic germline variants may affect the diagnosis and treatment decisions and hence potentially improve and personalize the patient care. In addition, the identification of such heritable risk is important for the family of the patients as they now may be provided genetic counseling and cancer surveillance if they are found to be carriers of the same variant.\nDetermining variant pathogenicity can be challenging due to the complexity and diversity of genetic variations. Evidence for variant interpretation may be scarce or conflicting which often leads variants to be classified as variants of uncertain significance (VUS).\nHow to determine the clinical significance, pathogenicity, of a variant?\nEvidence-based system for variant interpretation The American College of Medical Genetics and Genomics and the Association for Molecular Pathology (ACMG-AMP) (Richards et al., 2015) has developed guidelines for variant interpretation and is currently widely used system in this task.\nThe guidelines provide a standardized and systematic framework for evaluating the pathogenicity of germline variants. It is based on a system that looks through evidence for the variant and scores the evidence based on how strongly it supports pathogenicity or benignity.\nFor final variant interpretation the evidence for the variant in question is combined and variant will be assigned to one of the five pathogenicity classes: Pathogenic (P), Likely pathogenic (LP), Variant of uncertain significance (VUS), Likely benign (LB) or Benign (B) (Figure 1).\nFigure 1. ACMG classification system Evidence used for variant interpretation includes:\npopulation control data (eg. gnomAD (Karczewski, et al., 2020)) in silico /computation predictions (such as pathogenicity prediction score AlphaMissense (Cheng et al., 2023)) Functional data (eg. Hotspot regions) Clinical data/earlier findings (eg. ClinVar (Landrum et al., 2014)) In addition, the variant may be evaluated based on segregation, de novo, and allelic data if such information is available.\nAll the ACMG-AMP guideline evidence and their perceived strength can be seen from table 1.\nTable 1. Richards et al., ACMG classification rules Implementing the ACMG-AMP guidelines Multiple tools have been created to implement these guidelines, such as TAPES (Xavier et al., 2019). Recently, tools utilizing machine learning methods for variant prediction, such as MLVar (Nicora et al., 2022), have been published.These tools have been created to help automate the variant interpretation as going through a large number of variants manually is time-consuming task. Automation creates some restrictions because it is not possible to automate evidence such as segregation data which is patient specific. Some of these problems can be dealt with by making the user provide the additional data separately for the analysis.\nChallenges of the automated classification system Automation can speed up the analysis and help to filter and decrease the variant set to those predicted as pathogenic. However, because the rules allow for some subjectivity in the interpretation, there are inconsistencies between clinical laboratories (Kim et al., 2019). In addition, the varying prevalence of variants in different populations poses a challenge when determining whether a variant is rare or not.\nAnother huge challenge in the guidelines is the rules using lists of genes with some ‘known’ qualities. For example, very strong rule PVS1 is applied for a null variant located in a gene for which loss-of-function (LOF) is a known mechanism of disease. In practice, many tools interpret this rule by constructing a list of genes for which there are certain number of earlier identified pathogenic null variants. Benign rule, BP1 missense variant in a gene where only truncating variants cause disease, may reduce the importance of new pathogenic missense variant findings because in many cases disease associated genes have been found by identifying variants with clear, big impact (truncating/null variants).\nIt’s important to be aware of the potential caveats and limitations of the classification system, especially when identifying pathogenic variants in a clinical setting. ACMG system should work as a guideline to restrict the number of variants of interest for further inspection and not completely erase the manual work required to assess the importance of variants on patient level.\nMore work should still be done to clarify and develop the guidelines in order to reduce the inconsistencies. This is important also for the machine learning based methods because many tools use the variant databases, consisting of variants with manual or automated ACMG classifications, as training data.\nReferences Richards S, Aziz N, Bale S, et al. Standards and guidelines for the interpretation of sequence variants: a joint consensus recommendation of the American College of Medical Genetics and Genomics and the Association for Molecular Pathology. Genet Med. 17(5):405-424. (2015) doi:10.1038/gim.2015.30\nKarczewski KJ., Francioli LC., Tiao, G. et al. The mutational constraint spectrum quantified from variation in 141,456 humans. Nature ****581, 434–443 (2020). https://doi.org/10.1038/s41586-020-2308-7\nCheng J et al. Accurate proteome-wide missense variant effect prediction with AlphaMissense. Science 381,eadg7492(2023). DOI:10.1126/science.adg7492\nLandrum MJ, Lee JM, Riley GR, Jang W, Rubinstein WS, Church DM, Maglott DR. ClinVar: public archive of relationships among sequence variation and human phenotype. Nucleic Acids Res. 42(1):D980-5 (2014). doi: 10.1093/nar/gkt1113\nXavier A, Scott RJ, Talseth-Palmer BA. TAPES: A tool for assessment and prioritisation in exome studies. PLoS Comput Biol 15(10):e1007453 (2019). doi: 10.1371/journal.pcbi.1007453\nNicora, G., Zucca, S., Limongelli, I. et al. A machine learning approach based on ACMG/AMP guidelines for genomic variant classification and prioritization. Sci Rep 12, 2517 (2022). https://doi.org/10.1038/s41598-022-06547-3\nKim Y, Ki C, Jang M. Challenges and Considerations in Sequence Variant Interpretation for Mendelian Disorders. Ann Lab Med 39:421-429 (2019). https://doi.org/10.3343/alm.2019.39.5.421\n","permalink":"http://localhost:1313/posts/germline-variant-classification/","summary":"Germline variant effect interpretation is challenging Assessing the clinical significance of germline variants is an important task in genetics. Identification of pathogenic germline variants may affect the diagnosis and treatment decisions and hence potentially improve and personalize the patient care. In addition, the identification of such heritable risk is important for the family of the patients as they now may be provided genetic counseling and cancer surveillance if they are found to be carriers of the same variant.","title":"ACMG-AMP classification for germline variant pathogenicity"},{"content":"In silico protein folding Recent improvements in protein folding tools such as AlphaFold2 have dramatically changed protein structure research. In silico predictions have been able to reach comparable accuracy to experimental techniques such as X-ray crystallography and cryo-electron microscopy. These tools may be useful to help filter protein structures for experimental studies.\nMissense mutations Missense mutations are single nucleotide changes in nucleotide sequence that lead to amino acid change in the protein sequence. All single nucleotide changes don\u0026rsquo;t lead to amino acid change, but may result in synonymous mutation (no amino acid change), early stop codon (translation terminates) or a splicing change if located at splicing site.\nSingle nucleotide changes The effect of an amino acid change on protein structure and function is not always clear when only looking at the amino acid sequence. Some changes occur at known active sites or post-translational modification sites which may strongly indicate a deleterious effect on the protein function.\nBut what about the changes located outside of these sites?\nTraditionally the effect of the amino acid changes has been studied experimentally: producing protein products with the mutated amino acid, extracting the protein and solving its protein structure with for example X-ray crystallography. Experimental protocols are expensive and time-consuming and hence there\u0026rsquo;s a huge interest in pre-filtering the potential structures in cases where there are a large number of mutations of interest.\nCreating mutated sequences for in silico analysis I recently wanted to automate mutating protein FASTA sequences for AlphaFold2 protein folding and made a python script for that.\nSet API connection The script uses Ensembl REST API GRCh37 version and first sets a connection to the API:\n1import requests 2from requests.adapters import HTTPAdapter 3from requests.packages.urllib3.util.retry import Retry 4from requests_toolbelt import sessions 5 6 7def set_connection(): 8\tserver = \u0026#34;http://grch37.rest.ensembl.org\u0026#34; 9\tsession = sessions.BaseUrlSession(base_url = server) 10 11\tretry_strategy = Retry( 12\ttotal=3, 13\tbackoff_factor=2, 14\tstatus_forcelist=[429,500,502,503,504], 15\tmethod_whitelist=[\u0026#39;HEAD\u0026#39;,\u0026#39;GET\u0026#39;] 16\t) 17 18\tadapter = HTTPAdapter(max_retries=retry_strategy) 19\tsession.mount(\u0026#39;http://\u0026#39;,adapter) 20 21\treturn session 22 23 24session = set_connection() This creates a lasting connection to the API during which you can do multiple requests without closing and opening the connection each time.\nRead in data After the connection is set you read in the data, which is a text file with column \u0026ldquo;Protein_change\u0026rdquo; and one amino acid change of the format A256T per row (All changes for the SAME protein):\nProtein_change A356T V14F 1def read_data(data): 2 try: 3 datafile = pd.read_csv(data, sep=\u0026#39;\\t\u0026#39;) 4 except FileNotFoundError: 5 logging.exception(\u0026#34;Data file not found\u0026#34;) 6 sys.exit() 7 else: 8 logging.info(f\u0026#34;Datafile {data} read successfully.\u0026#34;) 9 return datafile 10 11data = read_data(File) Ideally you have all your amino acid changes for the same protein transcript but that is not always the case when gathering mutations from literature. Some proteins may have differing amino acid transcripts; longer/shorter versions, or older/newer versions that have a bit differing mutation locations. This script currently takes the default/most common protein sequence from Ensembl server based on Ensembl transcript ENST and checks if the location and amino acid matches. If the mutation belongs to different protein transcript, it is skipped.\nGet protein FASTA sequence First request the protein sequence (ENSP) from the API, and separate the ENSP name and amino acid sequence in their own variables:\n1def get_protein_seq(ENST,session): 2 ext = f\u0026#34;/sequence/id/{ENST}?type=protein\u0026#34; 3 4 p_seq = request_server(ext, session) 5 ESP,seq = p_seq.text.split(\u0026#39;\\n\u0026#39;,1) 6 seq = seq.replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) 7 logging.info(f\u0026#34;Read protein sequence {ESP} for transcript {ENST}.\u0026#34;) 8 return(ESP,seq) 9 10ENSP, seq = get_protein_seq(ENST,session) Make amino acid changes to the sequence Next, make an amino acid change to the amino acid sequence for the location specified in the \u0026lsquo;Protein_change\u0026rsquo; column of the data file. Make two lists, first containing the ENSP-code + amino acid change as a name for the sequence and the second one includes the mutated amino acid sequences.\n1def mutate_pseq(changes, ENSP, seq): 2 name_list = [] 3 seq_list = [] 4 5 name_list.append(f\u0026#39;{ENSP}_WT\u0026#39;) 6 seq_list.append(seq) 7 8 9 for c in changes[\u0026#39;Protein_change\u0026#39;]: 10\t#unmutated sequence 11 temp = seq 12\t#position of mutation eg. A265T -\u0026gt; 265 13 k = int(c[5:-3]) 14 15\t#checking if mutation is a missense mutation 16 if seq[k-1] == a_as[c[2:5]]: 17 temp2 = temp[:k-1] + a_as[c[-3:]] + temp[k:] 18 name_list.append(ENSP+\u0026#34;_\u0026#34;+c) 19 seq_list.append(temp2) 20 logging.info(f\u0026#34;Mutated protein sequence with change {c}.\u0026#34;) 21 else: 22\t#if not missense mutation 23\t#or mutation not on default protein sequence 24 logging.info(f\u0026#39;Something wrong with {c}\u0026#39;) 25 26 return(name_list, seq_list) 27 28nlist, slist = mutate_pseq(data, ENSP[1:-2], seq) Write results to a file Finally, write out the results as FASTA format to a single file:\nProtein FASTA format:\n\u0026gt;ENSP12344678_A345T ADGJRKAJGJRHJRJKDHEUIEJAHK\n1def save_seqs(nlist, slist, outname): 2 with open(f\u0026#34;{outname}.fasta\u0026#34;,\u0026#34;w\u0026#34;) as f: 3 for i in range(len(slist)): 4 f.write(nlist[i] + \u0026#34;\\n\u0026#34; + slist[i] + \u0026#34;\\n\u0026#34;) 5 6 logging.info(f\u0026#34;File {outname}.fasta saved.\u0026#34;) Summary / future to do\u0026rsquo;s Complete script can be found in github.\nFuture modifications to the script:\n[] Multiple isoform checks\n[] Add GRCh38 version API\n[] Make an option to write sequences to a single OR separate FASTA files\n","permalink":"http://localhost:1313/posts/mutating-protein-sequence/","summary":"In silico protein folding Recent improvements in protein folding tools such as AlphaFold2 have dramatically changed protein structure research. In silico predictions have been able to reach comparable accuracy to experimental techniques such as X-ray crystallography and cryo-electron microscopy. These tools may be useful to help filter protein structures for experimental studies.\nMissense mutations Missense mutations are single nucleotide changes in nucleotide sequence that lead to amino acid change in the protein sequence.","title":"Creating mutated protein sequences from a list of amino acid changes"},{"content":"I\u0026rsquo;m a PhD student in bioinformatics/genetics focusing on germline predisposition in hematological cancers and diseases.\nI\u0026rsquo;m mainly using python and bash for my coding tasks and occassionally R. In my projects I\u0026rsquo;m working on whole exome and genome sequencing data (somatic + germline), single cell RNAseq + ATACseq, and currently learning about metabolomics (UPLC-MS/MS) and proteomics (Olink) data. Lately, I\u0026rsquo;m heavily leaning on the single cell data side and highly interested in the interpretation and integration of multi-omics data.\nThis blog acts as my online notebook and learning diary and I will be writing mainly about the topics I\u0026rsquo;m learning about during my research.\n","permalink":"http://localhost:1313/about/","summary":"I\u0026rsquo;m a PhD student in bioinformatics/genetics focusing on germline predisposition in hematological cancers and diseases.\nI\u0026rsquo;m mainly using python and bash for my coding tasks and occassionally R. In my projects I\u0026rsquo;m working on whole exome and genome sequencing data (somatic + germline), single cell RNAseq + ATACseq, and currently learning about metabolomics (UPLC-MS/MS) and proteomics (Olink) data. Lately, I\u0026rsquo;m heavily leaning on the single cell data side and highly interested in the interpretation and integration of multi-omics data.","title":"About"}]