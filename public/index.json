[{"content":"Introduction Oncoplots are are visualisation tool used in genomics to present genetic mutations in a set of study samples. They provide an overview of the mutation/variant types and frequencies across all the samples. This allows for easier identification of recurrent and co-occuring mutations.\nEach column in the oncoplot represent a sample or individual, and each row corresponds to a gene. Mutation types are represented with different colors and symbols may be added to indicate extra information on the mutation.\nBasic oncoplot Oncoplots are often presented with additional information such as clinical parameters that can be added under, top, or to the sides of the oncoplot.\nThere are several tools for creating oncoplots and currently the most popular one is Bioconductor\u0026rsquo;s maftools oncoplot.\nWhy use oncoplots? Oncoplots are popular in cancer research because they make visualising complex data easier. Cancer genomes often carry a large number of mutations, which is why simplifying and visualising the most frequent ones is an important task.\nIn addition, oncoplot makes it easier to compare the mutation landscape between specific cancer types or therapeutic responses. This allows the identification of patterns associated with specific outcomes which can in turn gives new information about the cancer mechanisms or biomarkers for diagnosis.\nHow to create an oncoplot? Creating an oncoplot requires few steps from data preparation to visualisation.\nData requirements For this tutorial, you need genetic mutation data in MAF format. You can refer to this previous post on how to convert your annotated data into MAF format with a simple piece of code, or follow vcf2maf tutorial if you have VCF file.\nIf you want to add clinical information as metadata to the oncoplot, you need the clinical data in tabular format:\nTumor_Sample_Barcode Annotation1 Annotation2 Same sample codes as maf eg. diagnosis1 eg. sex Save the clinical data file with ending \u0026ldquo;.clin\u0026rdquo;\nTool requirements There are several tools and packages available for creating oncoplots. The most commonly used one is Bioconductor\u0026rsquo;s maftools oncoplot, a popular R package. For installation, run the following in R:\n1install.packages(\u0026#34;BiocManager\u0026#34;) 2BiocManager::install(\u0026#34;maftools\u0026#34;) In python, there are some options such as package fuc.\nCreating oncoplot with maftools oncoplot Read data Read in both MAF file with mutations and the optional clinical annotation file.\n1data \u0026lt;- read.table(\u0026#34;mutations.maf\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) 2clindata \u0026lt;- read.table(\u0026#34;clinicaldata.clin\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) Make any necessary filterings and changes to the file if needed. For example remember to modify VEP annotation mutation type nomenclature to an ANNOVAR types. Check the previous post on how to make a MAF file.\nCreate maftools dataobject Read files into maftools dataobject\n1laml \u0026lt;- read.maf(maf = data, 2\tclinicalData = clindata, 3\tverbose = FALSE) 4 5getClinicalData(x = laml) Set annotation colors Maftools gives default colors for mutation types and other annotations, but if you want to change these, you need to declare the color separately. Also, if you have a large number of variables in some annotations, for example 15 unique diagnosis types, it will be wise to make your own color palette.\nIf you have a reasonable number of variables in an annotation, you can use RColorBrewer and the color palettes. Many of the RColorBrewer color palettes allow maximum of 12 colors. To display all the available color palettes in RColorBrewer run the following lines:\n1library(RColorBrewer) 2display.brewer.all() RColorBrewer palettes First retrieve a number of colors from a palette you want and then assign them to the annotations. Here\u0026rsquo;s an example how to annotate each mutation type their own colors from the \u0026lsquo;Paired\u0026rsquo; palette.\n1vc_cols \u0026lt;- RColorBrewer::brewer.pal(n=6, name=\u0026#39;Paired\u0026#39;) 2names(vc_cols) \u0026lt;- c( 3\t\u0026#39;Frame_Shift_Del\u0026#39;, 4\t\u0026#39;Missense_Mutation\u0026#39;, 5\t\u0026#39;Nonsense_Mutation\u0026#39;, 6\t\u0026#39;Multi_Hit\u0026#39;, 7\t\u0026#39;Frame_shift_Ins\u0026#39;, 8\t\u0026#39;Splice_Site\u0026#39; 9) In case of more than 12 colors, it is probably the best to construct a palette of your own by declaring all the colors of the palette separately. This is also a good way to construct a palette if you want some specific or different colors for some annotations.\nHere I constructed a list of distinct colors and assigned them to cancer diagnoses and sex.\n1dx_cols \u0026lt;-c( 2\t\u0026#34;dodgerblue2\u0026#34;, \u0026#34;#E31A1C\u0026#34;, #red 3\t\u0026#34;green4\u0026#34;, \u0026#34;#6A3D9A\u0026#34;, # purple 4\t\u0026#34;#FF7F00\u0026#34;, # orange 5 \u0026#34;aquamarine3\u0026#34;, \u0026#34;gold1\u0026#34;, 6 \u0026#34;skyblue2\u0026#34;, \u0026#34;deeppink1\u0026#34;, # lt pink 7 \u0026#34;brown\u0026#34;, 8 \u0026#34;#CAB2D6\u0026#34;, # lt purple 9 \u0026#34;#FDBF6F\u0026#34;, # lt orange 10\t\u0026#34;gray70\u0026#34;, \u0026#34;khaki2\u0026#34;, 11 \u0026#34;maroon\u0026#34;, \u0026#34;orchid1\u0026#34;, \u0026#34;blue4\u0026#34;, \u0026#34;steelblue4\u0026#34;, 12 \u0026#34;darkturquoise\u0026#34;, \u0026#34;yellow4\u0026#34;, \u0026#34;yellow3\u0026#34;, 13 \u0026#34;darkorange4\u0026#34; 14) 15 16names(dx_cols) \u0026lt;- c( 17\t\u0026#34;AML\u0026#34;, \u0026#34;ALL\u0026#34;, \u0026#34;Breast\u0026#34;, 18\t\u0026#34;MM\u0026#34;, \u0026#34;Colon\u0026#34;, \u0026#34;Lung\u0026#34;,\u0026#34;Skin\u0026#34;, 19\t\u0026#34;BMF\u0026#34;,\u0026#34;Ovary\u0026#34;,\u0026#34;Lymphoma\u0026#34;, 20\t\u0026#34;Pancreas\u0026#34; 21) 22 23sex_cols \u0026lt;- c(\u0026#34;skyblue2\u0026#34;, \u0026#34;orchid3\u0026#34;) 24names(sex_cols) \u0026lt;- c(\u0026#34;M\u0026#34;,\u0026#34;F\u0026#34;) For annotations you need to save the colors into a list before making the oncoplot. Make sure that the list parameters (Dx_group and Sex in this case) are the same ones you have as column names in your clinical data annotation file!\n1anno_cols \u0026lt;- list(Dx_group=dx_cols, Sex=sex_cols Make oncoplot with clinical annotations You have a lot of options how to modify an oncoplot and I suggest you to look into maftools oncoplot documentation to find out what additional things you can do with oncoplots. Here, we will draw a basic oncoplot with two different clinical annotations at the bottom of the plot.\n1oncoplot(maf = laml, #read in the maftools dataobject 2\tcolors = vc_cols, #colors for mutation types 3\tclinicalFeatures = c(\u0026#34;Dx_group\u0026#34;, \u0026#34;Sex\u0026#34;), #the column names of features in the annotation file 4\tannotationColor = anno_cols, #list of colors for annotations 5\tremoveNonMutated = TRUE, #doesn\u0026#39;t show samples if there are no mutations 6\tshowTitle = FALSE, 7\ttop = 10, #show only top 10 mutated genes 8\tshowPct = FALSE, #shows percentage of individuals carrying mutation in a gene 9\tdrawColBar = FALSE #draws a barplot on top to show how many mutations each individual have 10) And this gives a basic oncoplot with two clinical annotations. Sometimes you may need to adjust the legend parameters in order to make all the legends with (mutation type, Dx_group and Sex should all have their own legens underneath the oncoplot). Parameters to adjust for this are for example: legend_height, anno_height, gene_mar, annotationFontSize.\nBasic oncoplot References maftools oncoplot documentation vcf2maf documentation ","permalink":"http://localhost:1313/posts/oncoplot/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eOncoplots are are visualisation tool used in genomics to present genetic mutations in a set of study samples.\nThey provide an overview of the mutation/variant types and frequencies across all the samples.\nThis allows for easier identification of recurrent and co-occuring mutations.\u003c/p\u003e\n\u003cp\u003eEach column in the oncoplot represent a sample or individual, and each row corresponds to a gene.\nMutation types are represented with different colors and symbols may be added to indicate extra information on the mutation.\u003c/p\u003e","title":"Oncoplot"},{"content":"Check all articles in this list.\nMAF files Mutation Annotation Format (MAF) is a data format used to store mutation data. Some visualization tools such as Bioconductor\u0026rsquo;s oncoplot, require the data to be in MAF format.\nMAF files have mandatory and optional fields. Mandatory fields:\nHugo_Symbol: Gene name (it\u0026rsquo;s Hugo nomenclature name) Chromosome Start_Position End_Position Reference_allele Tumor_Seq_Allele2: alternative allele Variant_Classification: variant consequence eg. missense, stop, splice Variant_Type: single nucleotide variant, insertion, deletion Tumor_Sample_Barcode:\tTumor/Patient/Sample name or number Optional fields:\nnon MAF specific fields containing VAF and amino acid change information Generating MAF files When generating MAF files your starting point is usually a VCF file or a tabular file with or without annotations. Tool vcf2maf will annotate, prioritize transcripts, and generates a MAF suitable for further use. The tool requires VEP to be installed in order for it to be able to do the annotations for mutations.\nBecause I already had a VEP-annotated tabular file, I used python to generate MAF file and R to change the values in Variant_Type and Variant_Classification columns to be maftools oncoplot compatible. More about bioconductor\u0026rsquo;s maftools can be found here.\nVEP annotated tabular file to MAF file Taking the required fields from the VEP-annotated tabular file and renaming the column names into oncoplot suitable ones.\n1import pandas as pd 2 3def make_maf(data): 4\tdata[\u0026#39;End_Position\u0026#39;] = data[\u0026#39;pos\u0026#39;] + 1 5\tmaf = data[[\u0026#39;SYMBOL\u0026#39;,\u0026#39;chrom\u0026#39;,\u0026#39;pos\u0026#39;,\u0026#39;End_Position\u0026#39;,\u0026#39;ref\u0026#39;,\u0026#39;alt\u0026#39;,\u0026#39;Consequence\u0026#39;,\u0026#39;VARIANT_CLASS\u0026#39;, \u0026#39;patient\u0026#39;]] 6\tmaf.columns = [\u0026#39;Hugo_Symbol\u0026#39;, \u0026#39;Chromosome\u0026#39;,\u0026#39;Start_Position\u0026#39;,\u0026#39;End_Position\u0026#39;, \u0026#39;Reference_Allele\u0026#39;, \u0026#39;Tumor_Seq_Allele2\u0026#39;,\u0026#39;Variant_Classification\u0026#39;,\u0026#39;Variant_Type\u0026#39;,\u0026#39;Tumor_Sample_Barcode\u0026#39;] 7\treturn maf 8 9maf = make_maf(data) Modify variant annotations In addition to VEP, there\u0026rsquo;s another popular variant annotation tool ANNOVAR. They use a bit different nomenclature on the variant consequence and variant type fields. Maftools oncoplot uses the ANNOVAR type of annotations and hence in R, I change the Variant_Type and Variant_Classification values from VEP nomenclature to ANNOVAR nomenclature.\n1library(dplyr) 2 3data \u0026lt;- read.table(\u0026#39;variants.maf\u0026#39;, sep=\u0026#39;\\t\u0026#39;, header=TRUE) 4 5change_values \u0026lt;- function(df) { 6\tdf \u0026lt;- df %\u0026gt;% 7\tmutate(Variant_Classification = case_when((Variant_Classification == \u0026#39;missense_variant\u0026#39;) ~ \u0026#39;Missense_Mutation\u0026#39;, 8\t(Variant_Classification == \u0026#39;stop_gained\u0026#39;) ~ \u0026#39;Nonsense_Mutation\u0026#39;, 9\t(Variant_Classification == \u0026#39;splice_acceptor_variant\u0026#39;) ~ \u0026#39;Splice_Site\u0026#39;, 10\t(Variant_Classification == \u0026#39;splice_donor_variant\u0026#39;) ~ \u0026#39;Splice_Site\u0026#39;, 11\t(Variant_Classification == \u0026#39;missense_variant\u0026amp;splice_region_variant\u0026#39;) ~ \u0026#39;Missense_Mutation\u0026#39;, 12\t(Variant_Classification == \u0026#39;frameshift_variant\u0026#39; \u0026amp; Variant_Type ==\u0026#39;deletion\u0026#39;) ~ \u0026#39;Frame_Shift_Del\u0026#39;, 13\t(Variant_Classification == \u0026#39;start_lost\u0026#39;) ~ \u0026#39;Nonsense_Mutation\u0026#39;, 14\t(Variant_Classification == \u0026#39;frameshift_variant \u0026amp; Variant_Type == \u0026#39;insertion\u0026#39;) ~ \u0026#39;Frame_Shift_Ins\u0026#39;)) %\u0026gt;% 15\tmutate(Variant_Type = case_when((Variant_Type == \u0026#39;SNV\u0026#39;) ~ \u0026#39;SNP\u0026#39;, 16\t(Variant_Type == \u0026#39;insertion\u0026#39;) ~ \u0026#39;INS\u0026#39;, 17\t(Variant_Type == \u0026#39;deletion\u0026#39;) ~ \u0026#39;DEL\u0026#39;)) 18 19\treturn(df) 20} 21 22data \u0026lt;- change_values(data) Be careful with the variant nomenclature Each tool, VEP, ANNOVAR, and other annotation tools use different systems for variant nomenclature and they may vary. ANNOVAR annotations are more general compared to VEP. For example, in ANNOVAR, splice-site variants are annotated as \u0026lsquo;Splice_Site\u0026rsquo;, whereas in VEP they are annotated as \u0026lsquo;splice_acceptor_variant\u0026rsquo; or \u0026lsquo;splice_donor_variant\u0026rsquo; depending on their location. In addition, variants in multiple transcripts are dealt with differently. Some tools list each different annotation the variant gets in the different transcripts whereas for example, ANNOVAR outputs only the most deleterious variant based on their priorisation system.\nReferences VEP: https://asia.ensembl.org/info/docs/tools/vep/index.html ANNOVAR: https://annovar.openbioinformatics.org/en/latest/\n","permalink":"http://localhost:1313/posts/make-maf-for-oncoplot/","summary":"\u003cp\u003e\u003ca href=\"http://localhost:1313/series/bio-visualisation-tools/\"\u003eCheck all articles in this list\u003c/a\u003e.\u003c/p\u003e\n\u003ch1 id=\"maf-files\"\u003eMAF files\u003c/h1\u003e\n\u003cp\u003eMutation Annotation Format (MAF) is a data format used to store mutation data.\nSome visualization tools such as Bioconductor\u0026rsquo;s oncoplot, require the data\nto be in MAF format.\u003c/p\u003e\n\u003cp\u003eMAF files have mandatory and optional fields.\nMandatory fields:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHugo_Symbol: Gene name (it\u0026rsquo;s Hugo nomenclature name)\u003c/li\u003e\n\u003cli\u003eChromosome\u003c/li\u003e\n\u003cli\u003eStart_Position\u003c/li\u003e\n\u003cli\u003eEnd_Position\u003c/li\u003e\n\u003cli\u003eReference_allele\u003c/li\u003e\n\u003cli\u003eTumor_Seq_Allele2: alternative allele\u003c/li\u003e\n\u003cli\u003eVariant_Classification: variant consequence eg. missense, stop, splice\u003c/li\u003e\n\u003cli\u003eVariant_Type: single nucleotide variant, insertion, deletion\u003c/li\u003e\n\u003cli\u003eTumor_Sample_Barcode:\tTumor/Patient/Sample name or number\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOptional fields:\u003c/p\u003e","title":"Make Maf for Oncoplot"},{"content":"What is a reference genome? A human reference genome, reference assembly, is a sequence of nucleotides representing genes and non-coding regions of the genome. It is made up from a combination multiple individual\u0026rsquo;s DNA and hence not representing a genome of any single human but an average of all humans in the world. However, it is difficult to get proper representation of all humans due to the bias in the selection of participants for the genome sequencing and the great variantion in some parts of the genome between populations. The first version was released in 2000 and there have been multiple improvements and versions after that.\nWhat is it used for? Reference genomes are used in genetic research as a reference map to help assemble sequencing data. They are also used in sample comparison to identify differences in the genome between individuals.\nWhat are the different versions? Institutional differences There are number of reference genome assemblies available from different sources which are then named based on the institution.\nReference Institute Contig names Resource Notes GRCh37, GRCh38 The Genome Reference Consortium (GRC) chr prefix ftp://ftp.ncbi.nlm.nih.gov/genomes/refseq/vertebrate_mammalian/Homo_sapiens/all_assembly_versions/GCF_000001405.25_GRCh37.p13/GCF_000001405.25_GRCh37.p13_genomic.fna.gz Constructed from sequenced bacterial artificial chromosomes (BACs) hg19, hg38 The University of California at Santa Cruz (UCSC) chr prefix http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/hg19.fa.gz Based on GRCh reference but contains some alterations b37 Broad institute no \u0026lsquo;chr\u0026rsquo; prefix https://console.cloud.google.com/storage/browser/_details/broad-references/hg19/v0/Homo_sapiens_assembly19.fasta Based on GRCh. Alterations: bases with low confidence masked out. human_g1k_v37 The 1000 Genome project No \u0026lsquo;chr\u0026rsquo; prefix http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/reference/human_g1k_v37.fasta.gz Equivalent to b37, but without human herpesvirus 4 type 1 decoy sequence Mostly the references contain the same data, although they use different naming for contigs (hg19 and GRCh use ‘chr’ prefix whereas other two don’t).\nHowever, there are some sequence differences between the references. There are differences on chromosomes 3 and Y, and mitochondrial contig as can be seen on the reference comparison table at broad institutes article linked below.\nRelease builds 37 vs 38 Each major version of human reference genome assemblies are numbered differently and the latest ones are GRCh37 (release 2009) and GRCh38 (release 2013) (hg19 and hg38 in the UCSC). Each version comes with updated annotations to the earlier.\nGRCh38 assembly has repaired incorrect reads and misassembled areas in GRCh37. In addition, it has been updated to include model centromere sequences and alternate loci. GRCh38 has greater amoun of ALT contigs, which are pieces of genome that represent alternative haplotypes.\nReferences: https://www.science.org/doi/10.1126/science.abj6987\nhttps://gatk.broadinstitute.org/hc/en-us/articles/360035890711-GRCh37-hg19-b37-humanG1Kv37-Human-Reference-Discrepancies?id=23390\nhttps://www.ncbi.nlm.nih.gov/grc\n","permalink":"http://localhost:1313/posts/human-reference-genomes/","summary":"\u003ch2 id=\"what-is-a-reference-genome\"\u003eWhat is a reference genome?\u003c/h2\u003e\n\u003cp\u003eA human reference genome, reference assembly, is a sequence of nucleotides representing genes\nand non-coding regions of the genome.\nIt is made up from a combination multiple individual\u0026rsquo;s DNA and hence not representing a\ngenome of any single human but an average of all humans in the world. However,\nit is difficult to get proper representation of all humans due to the bias in the\nselection of participants for the genome sequencing and the great variantion in some parts\nof the genome between populations.\nThe first version was released in 2000 and there have been\nmultiple improvements and versions after that.\u003c/p\u003e","title":"Human Reference Genomes: GRCh37, GRCh38, hg19, hg38, v37, b37?"},{"content":"Germline variant effect interpretation is challenging Assessing the clinical significance of germline variants is an important task in genetics. Identification of pathogenic germline variants may affect the diagnosis and treatment decisions and hence potentially improve and personalize the patient care. In addition, the identification of such heritable risk is important for the family of the patients as they now may be provided genetic counseling and cancer surveillance if they are found to be carriers of the same variant.\nDetermining variant pathogenicity can be challenging due to the complexity and diversity of genetic variations. Evidence for variant interpretation may be scarce or conflicting which often leads variants to be classified as variants of uncertain significance (VUS).\nHow to determine the clinical significance, pathogenicity, of a variant?\nEvidence-based system for variant interpretation The American College of Medical Genetics and Genomics and the Association for Molecular Pathology (ACMG-AMP) (Richards et al., 2015) has developed guidelines for variant interpretation and is currently widely used system in this task.\nThe guidelines provide a standardized and systematic framework for evaluating the pathogenicity of germline variants. It is based on a system that looks through evidence for the variant and scores the evidence based on how strongly it supports pathogenicity or benignity.\nFor final variant interpretation the evidence for the variant in question is combined and variant will be assigned to one of the five pathogenicity classes: Pathogenic (P), Likely pathogenic (LP), Variant of uncertain significance (VUS), Likely benign (LB) or Benign (B) (Figure 1).\nFigure 1. ACMG classification system Evidence used for variant interpretation includes:\npopulation control data (eg. gnomAD (Karczewski, et al., 2020)) in silico /computation predictions (such as pathogenicity prediction score AlphaMissense (Cheng et al., 2023)) Functional data (eg. Hotspot regions) Clinical data/earlier findings (eg. ClinVar (Landrum et al., 2014)) In addition, the variant may be evaluated based on segregation, de novo, and allelic data if such information is available.\nAll the ACMG-AMP guideline evidence and their perceived strength can be seen from table 1.\nTable 1. Richards et al., ACMG classification rules Implementing the ACMG-AMP guidelines Multiple tools have been created to implement these guidelines, such as TAPES (Xavier et al., 2019). Recently, tools utilizing machine learning methods for variant prediction, such as MLVar (Nicora et al., 2022), have been published.These tools have been created to help automate the variant interpretation as going through a large number of variants manually is time-consuming task. Automation creates some restrictions because it is not possible to automate evidence such as segregation data which is patient specific. Some of these problems can be dealt with by making the user provide the additional data separately for the analysis.\nChallenges of the automated classification system Automation can speed up the analysis and help to filter and decrease the variant set to those predicted as pathogenic. However, because the rules allow for some subjectivity in the interpretation, there are inconsistencies between clinical laboratories (Kim et al., 2019). In addition, the varying prevalence of variants in different populations poses a challenge when determining whether a variant is rare or not.\nAnother huge challenge in the guidelines is the rules using lists of genes with some ‘known’ qualities. For example, very strong rule PVS1 is applied for a null variant located in a gene for which loss-of-function (LOF) is a known mechanism of disease. In practice, many tools interpret this rule by constructing a list of genes for which there are certain number of earlier identified pathogenic null variants. Benign rule, BP1 missense variant in a gene where only truncating variants cause disease, may reduce the importance of new pathogenic missense variant findings because in many cases disease associated genes have been found by identifying variants with clear, big impact (truncating/null variants).\nIt’s important to be aware of the potential caveats and limitations of the classification system, especially when identifying pathogenic variants in a clinical setting. ACMG system should work as a guideline to restrict the number of variants of interest for further inspection and not completely erase the manual work required to assess the importance of variants on patient level.\nMore work should still be done to clarify and develop the guidelines in order to reduce the inconsistencies. This is important also for the machine learning based methods because many tools use the variant databases, consisting of variants with manual or automated ACMG classifications, as training data.\nReferences Richards S, Aziz N, Bale S, et al. Standards and guidelines for the interpretation of sequence variants: a joint consensus recommendation of the American College of Medical Genetics and Genomics and the Association for Molecular Pathology. Genet Med. 17(5):405-424. (2015) doi:10.1038/gim.2015.30\nKarczewski KJ., Francioli LC., Tiao, G. et al. The mutational constraint spectrum quantified from variation in 141,456 humans. Nature ****581, 434–443 (2020). https://doi.org/10.1038/s41586-020-2308-7\nCheng J et al. Accurate proteome-wide missense variant effect prediction with AlphaMissense. Science 381,eadg7492(2023). DOI:10.1126/science.adg7492\nLandrum MJ, Lee JM, Riley GR, Jang W, Rubinstein WS, Church DM, Maglott DR. ClinVar: public archive of relationships among sequence variation and human phenotype. Nucleic Acids Res. 42(1):D980-5 (2014). doi: 10.1093/nar/gkt1113\nXavier A, Scott RJ, Talseth-Palmer BA. TAPES: A tool for assessment and prioritisation in exome studies. PLoS Comput Biol 15(10):e1007453 (2019). doi: 10.1371/journal.pcbi.1007453\nNicora, G., Zucca, S., Limongelli, I. et al. A machine learning approach based on ACMG/AMP guidelines for genomic variant classification and prioritization. Sci Rep 12, 2517 (2022). https://doi.org/10.1038/s41598-022-06547-3\nKim Y, Ki C, Jang M. Challenges and Considerations in Sequence Variant Interpretation for Mendelian Disorders. Ann Lab Med 39:421-429 (2019). https://doi.org/10.3343/alm.2019.39.5.421\n","permalink":"http://localhost:1313/posts/germline-variant-classification/","summary":"\u003ch2 id=\"germline-variant-effect-interpretation-is-challenging\"\u003eGermline variant effect interpretation is challenging\u003c/h2\u003e\n\u003cp\u003eAssessing the clinical significance of germline variants is an important task in genetics. Identification of pathogenic germline variants may affect the diagnosis and treatment decisions and hence potentially improve and personalize the patient care. In addition, the identification of such heritable risk is important for the family of the patients as they now may be provided genetic counseling and cancer surveillance if they are found to be carriers of the same variant.\u003c/p\u003e","title":"ACMG-AMP classification for germline variant pathogenicity"},{"content":"In silico protein folding Recent improvements in protein folding tools such as AlphaFold2 have dramatically changed protein structure research. In silico predictions have been able to reach comparable accuracy to experimental techniques such as X-ray crystallography and cryo-electron microscopy. These tools may be useful to help filter protein structures for experimental studies.\nMissense mutations Missense mutations are single nucleotide changes in nucleotide sequence that lead to amino acid change in the protein sequence. All single nucleotide changes don\u0026rsquo;t lead to amino acid change, but may result in synonymous mutation (no amino acid change), early stop codon (translation terminates) or a splicing change if located at splicing site.\nSingle nucleotide changes The effect of an amino acid change on protein structure and function is not always clear when only looking at the amino acid sequence. Some changes occur at known active sites or post-translational modification sites which may strongly indicate a deleterious effect on the protein function.\nBut what about the changes located outside of these sites?\nTraditionally the effect of the amino acid changes has been studied experimentally: producing protein products with the mutated amino acid, extracting the protein and solving its protein structure with for example X-ray crystallography. Experimental protocols are expensive and time-consuming and hence there\u0026rsquo;s a huge interest in pre-filtering the potential structures in cases where there are a large number of mutations of interest.\nCreating mutated sequences for in silico analysis I recently wanted to automate mutating protein FASTA sequences for AlphaFold2 protein folding and made a python script for that.\nSet API connection The script uses Ensembl REST API GRCh37 version and first sets a connection to the API:\n1import requests 2from requests.adapters import HTTPAdapter 3from requests.packages.urllib3.util.retry import Retry 4from requests_toolbelt import sessions 5 6 7def set_connection(): 8\tserver = \u0026#34;http://grch37.rest.ensembl.org\u0026#34; 9\tsession = sessions.BaseUrlSession(base_url = server) 10 11\tretry_strategy = Retry( 12\ttotal=3, 13\tbackoff_factor=2, 14\tstatus_forcelist=[429,500,502,503,504], 15\tmethod_whitelist=[\u0026#39;HEAD\u0026#39;,\u0026#39;GET\u0026#39;] 16\t) 17 18\tadapter = HTTPAdapter(max_retries=retry_strategy) 19\tsession.mount(\u0026#39;http://\u0026#39;,adapter) 20 21\treturn session 22 23 24session = set_connection() This creates a lasting connection to the API during which you can do multiple requests without closing and opening the connection each time.\nRead in data After the connection is set you read in the data, which is a text file with column \u0026ldquo;Protein_change\u0026rdquo; and one amino acid change of the format A256T per row (All changes for the SAME protein):\nProtein_change A356T V14F 1def read_data(data): 2 try: 3 datafile = pd.read_csv(data, sep=\u0026#39;\\t\u0026#39;) 4 except FileNotFoundError: 5 logging.exception(\u0026#34;Data file not found\u0026#34;) 6 sys.exit() 7 else: 8 logging.info(f\u0026#34;Datafile {data} read successfully.\u0026#34;) 9 return datafile 10 11data = read_data(File) Ideally you have all your amino acid changes for the same protein transcript but that is not always the case when gathering mutations from literature. Some proteins may have differing amino acid transcripts; longer/shorter versions, or older/newer versions that have a bit differing mutation locations. This script currently takes the default/most common protein sequence from Ensembl server based on Ensembl transcript ENST and checks if the location and amino acid matches. If the mutation belongs to different protein transcript, it is skipped.\nGet protein FASTA sequence First request the protein sequence (ENSP) from the API, and separate the ENSP name and amino acid sequence in their own variables:\n1def get_protein_seq(ENST,session): 2 ext = f\u0026#34;/sequence/id/{ENST}?type=protein\u0026#34; 3 4 p_seq = request_server(ext, session) 5 ESP,seq = p_seq.text.split(\u0026#39;\\n\u0026#39;,1) 6 seq = seq.replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) 7 logging.info(f\u0026#34;Read protein sequence {ESP} for transcript {ENST}.\u0026#34;) 8 return(ESP,seq) 9 10ENSP, seq = get_protein_seq(ENST,session) Make amino acid changes to the sequence Next, make an amino acid change to the amino acid sequence for the location specified in the \u0026lsquo;Protein_change\u0026rsquo; column of the data file. Make two lists, first containing the ENSP-code + amino acid change as a name for the sequence and the second one includes the mutated amino acid sequences.\n1def mutate_pseq(changes, ENSP, seq): 2 name_list = [] 3 seq_list = [] 4 5 name_list.append(f\u0026#39;{ENSP}_WT\u0026#39;) 6 seq_list.append(seq) 7 8 9 for c in changes[\u0026#39;Protein_change\u0026#39;]: 10\t#unmutated sequence 11 temp = seq 12\t#position of mutation eg. A265T -\u0026gt; 265 13 k = int(c[5:-3]) 14 15\t#checking if mutation is a missense mutation 16 if seq[k-1] == a_as[c[2:5]]: 17 temp2 = temp[:k-1] + a_as[c[-3:]] + temp[k:] 18 name_list.append(ENSP+\u0026#34;_\u0026#34;+c) 19 seq_list.append(temp2) 20 logging.info(f\u0026#34;Mutated protein sequence with change {c}.\u0026#34;) 21 else: 22\t#if not missense mutation 23\t#or mutation not on default protein sequence 24 logging.info(f\u0026#39;Something wrong with {c}\u0026#39;) 25 26 return(name_list, seq_list) 27 28nlist, slist = mutate_pseq(data, ENSP[1:-2], seq) Write results to a file Finally, write out the results as FASTA format to a single file:\nProtein FASTA format:\n\u0026gt;ENSP12344678_A345T ADGJRKAJGJRHJRJKDHEUIEJAHK\n1def save_seqs(nlist, slist, outname): 2 with open(f\u0026#34;{outname}.fasta\u0026#34;,\u0026#34;w\u0026#34;) as f: 3 for i in range(len(slist)): 4 f.write(nlist[i] + \u0026#34;\\n\u0026#34; + slist[i] + \u0026#34;\\n\u0026#34;) 5 6 logging.info(f\u0026#34;File {outname}.fasta saved.\u0026#34;) Summary / future to do\u0026rsquo;s Complete script can be found in github.\nFuture modifications to the script:\n[] Multiple isoform checks\n[] Add GRCh38 version API\n[] Make an option to write sequences to a single OR separate FASTA files\n","permalink":"http://localhost:1313/posts/mutating-protein-sequence/","summary":"\u003ch1 id=\"in-silico-protein-folding\"\u003e\u003cem\u003eIn silico\u003c/em\u003e protein folding\u003c/h1\u003e\n\u003cp\u003eRecent improvements in protein \u003ca href=\"https://github.com/biolists/folding_tools\"\u003efolding tools\u003c/a\u003e such as AlphaFold2\nhave dramatically changed protein structure research. \u003cem\u003eIn silico\u003c/em\u003e predictions have been able to reach comparable accuracy to experimental techniques such as X-ray crystallography and cryo-electron microscopy.\nThese tools may be useful to help filter protein structures for experimental studies.\u003c/p\u003e\n\u003ch1 id=\"missense-mutations\"\u003eMissense mutations\u003c/h1\u003e\n\u003cp\u003eMissense mutations are single nucleotide changes in nucleotide sequence that lead to amino acid change in the\nprotein sequence. All single nucleotide changes don\u0026rsquo;t lead to amino acid change, but may result in synonymous mutation\n(no amino acid change), early stop codon (translation terminates) or a splicing change if located at splicing site.\u003c/p\u003e","title":"Creating mutated protein sequences from a list of amino acid changes"},{"content":"I\u0026rsquo;m a PhD student in bioinformatics/genetics focusing on germline predisposition in hematological cancers and diseases.\nI\u0026rsquo;m mainly using python and bash for my coding tasks and occassionally R. In my projects I\u0026rsquo;m working on whole exome and genome sequencing data (somatic + germline), single cell RNAseq + ATACseq, and currently learning about metabolomics (UPLC-MS/MS) and proteomics (Olink) data. Lately, I\u0026rsquo;m heavily leaning on the single cell data side and highly interested in the interpretation and integration of multi-omics data.\nThis blog acts as my online notebook and learning diary and I will be writing mainly about the topics I\u0026rsquo;m learning about during my research.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI\u0026rsquo;m a PhD student in bioinformatics/genetics focusing on germline predisposition\nin hematological cancers and diseases.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m mainly using python and bash for my coding tasks and occassionally R. In my projects I\u0026rsquo;m working on\nwhole exome and genome sequencing data (somatic + germline), single cell RNAseq + ATACseq,\nand currently learning about metabolomics (UPLC-MS/MS) and proteomics (Olink) data. Lately, I\u0026rsquo;m heavily\nleaning on the single cell data side and highly interested in the interpretation and integration of\nmulti-omics data.\u003c/p\u003e","title":"About"}]